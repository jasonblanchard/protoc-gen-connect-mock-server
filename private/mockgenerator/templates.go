package mockgenerator

import (
	"bytes"
	"fmt"
	"text/template"
)

type ImportsStringInput struct {
	PkgName string
	GoImportPath string
	ConnectFilePath string
	Dependencies []string
}

func importsString(i *ImportsStringInput) (string, error) {
	tmpl, err := template.New("imports").Parse(importsTpl)

	if err != nil {
		return "", fmt.Errorf("error parsing template: %w", err)
	}

	buf := bytes.NewBufferString("")

	tmpl.Execute(buf, i)

	return buf.String(), nil
}

const importsTpl = `// Code generated by {{.PkgName}}. DO NOT EDIT.
package main

import (
	connect_go "github.com/bufbuild/connect-go"
	context "context"
	"flag"
	"net/http"
	"time"
	"github.com/rs/cors"
	"golang.org/x/exp/slog"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"
	"github.com/go-faker/faker/v4"
	{{ .GoImportPath }}
	"{{ .ConnectFilePath }}"
	{{ range $dep := .Dependencies }}
		{{ $dep }}
	{{ end }}
)

var isDynamic bool

func getStringValue() string {
	if !isDynamic {
		return "string"
	}

	type Container struct {
		Value string
	}

	a := &Container{}
	err := faker.FakeData(a)
	
	if err != nil {
		return err.Error()
	}

	return a.Value
}

func getInt32Value() int32 {
	if !isDynamic {
		return 123
	}

	type Container struct {
		Value int32
	}

	a := &Container{}
	err := faker.FakeData(a)
	
	if err != nil {
		return 0
	}

	return a.Value
}

func getBoolValue() bool {
	if !isDynamic {
		return true
	}

	type Container struct {
		Value bool
	}

	a := &Container{}
	err := faker.FakeData(a)
	
	if err != nil {
		return true
	}

	return a.Value
}

`

type MainFuncHandler struct {
	ConnectPkg string
	ServiceName string
}

type MainFuncStringInput struct {
	Handlers []MainFuncHandler
}

func mainFuncString(i *MainFuncStringInput) (string, error) {
	serverHandler, err := template.New("serverHandler").Parse(serverHandlerTpl)

	if err != nil {
		return "", fmt.Errorf("error parsing server handler template: %w", err)
	}

	mainFunc, err := serverHandler.New("mainFunc").Parse(mainFuncTpl)

	if err != nil {
		return "", fmt.Errorf("error parsing mainFunc template: %w", err)
	}

	buf := bytes.NewBufferString("")

	mainFunc.Execute(buf, i)

	return buf.String(), nil
}

const serverHandlerTpl = `{{ .ServiceName }}server := &{{ .ServiceName }}MockServer{}
	{{ .ServiceName }}path, {{ .ServiceName }}handler := {{ .ConnectPkg }}.New{{ .ServiceName }}Handler({{ .ServiceName }}server)
	mux.Handle({{ .ServiceName }}path, WithLogging({{ .ServiceName }}handler))`

const mainFuncTpl = `func main() {
	var portVar string
	flag.StringVar(&portVar, "port", "8080", "port to run the mock server on")
	flag.StringVar(&portVar, "p", "8080", "port to run the mock server on (shorthand)")
	flag.BoolVar(&isDynamic, "d", false, "return dynamic values (shorthand)")

	flag.Parse()

	mux := http.NewServeMux()
	{{ range $handler := .Handlers }}
		{{ template "serverHandler" $handler }}
	{{ end }}
	corsHandler := cors.New(cors.Options{
		AllowedOrigins:   []string{"https://buf.build"},
		AllowCredentials: true,
		AllowedMethods:   []string{http.MethodPost, http.MethodOptions},
		AllowedHeaders:   []string{"*"},
	}).Handler(mux)
	slog.Info("Server starting", "port", portVar)
	http.ListenAndServe(":" + portVar, h2c.NewHandler(corsHandler, &http2.Server{}))
}

func WithLogging(h http.Handler) http.Handler {
    logFn := func(rw http.ResponseWriter, r *http.Request) {
		start := time.Now()

		h.ServeHTTP(rw, r)

		duration := time.Since(start)

		slog.Info("request", "proto", r.Proto, "method", r.Method, "host", r.Host, "uri", r.RequestURI, "remoteAddr", r.RemoteAddr, "duration", duration)
    }
    return http.HandlerFunc(logFn)
}`

type MockMethod struct {
	MockServerName string
	GoName string
	InputName string
	OutputName string
	PkgNamespace string
}

type MockServerInput struct {
	GoName string
	Methods []MockMethod
}

func mockServerString(i *MockServerInput) (string, error) {
	serverHandler, err := template.New("mockServerMethod").Parse(mockServerMethodTpl)

	if err != nil {
		return "", fmt.Errorf("error parsing mockServerMethod template: %w", err)
	}

	mainFunc, err := serverHandler.New("mockServer").Parse(mockServerTpl)

	if err != nil {
		return "", fmt.Errorf("error parsing mockMessage template: %w", err)
	}

	buf := bytes.NewBufferString("")

	mainFunc.Execute(buf, i)

	return buf.String(), nil
}

const mockServerMethodTpl = `func ({{ .MockServerName }}) {{ .GoName }}(context.Context, *connect_go.Request[{{ .PkgNamespace }}.{{ .InputName }}]) (*connect_go.Response[{{ .PkgNamespace }}.{{ .OutputName }}], error) {
	resp := &connect_go.Response[{{ .PkgNamespace }}.{{ .OutputName }}]{}
	resp.Msg = {{ .PkgNamespace }}_NewMock{{ .OutputName }}()
	return resp, nil
}`

const mockServerTpl = `type {{ .GoName }}MockServer struct{}
{{ range $method := .Methods }}
		{{ template "mockServerMethod" $method }}
{{ end }}`

type Field struct {
	Name string
	Value string
}

type MockMessageInput struct {
	Name string
	Fields []Field
	PkgNamespace string
}

func mockMessageString(i *MockMessageInput) (string, error) {
	serverHandler, err := template.New("messageField").Parse(messageFieldTpl)

	if err != nil {
		return "", fmt.Errorf("error parsing server handler template: %w", err)
	}

	mainFunc, err := serverHandler.New("mockMessage").Parse(mockMessageTpl)

	if err != nil {
		return "", fmt.Errorf("error parsing mockMessage template: %w", err)
	}

	buf := bytes.NewBufferString("")

	mainFunc.Execute(buf, i)

	return buf.String(), nil
}

const messageFieldTpl = `{{ .Name }}: {{ .Value }},`

const mockMessageTpl = `func {{ .PkgNamespace }}_NewMock{{ .Name }}() *{{ .PkgNamespace }}.{{ .Name }}  {
	mock := &{{ .PkgNamespace }}.{{ .Name }} { {{ range $field := .Fields }}
		{{ template "messageField" $field }}{{ end }}
	}
	return mock
}`